local a=require("cc.expect")local a,b=a.expect,a.field;local function c(d,e)a(1,d,"string")if d=="array"then if type(e)~="table"then return false end;for f,g in ipairs(e)do if type(f)~="number"then return false end end;return true end;return type(e)==d end;local function h(i,j)a(1,i,"string")j=j or 1;a(2,j,"number","nil")error(i,j)end;local function k(l,e,m)a(1,l,"table","nil")a(2,e,"any")a(3,m,"string")l=l or{}if not l.message then return m end;if type(l.message)=="function"then return l.message(e)end;if string.find(l.message,"%%s")then return string.format(l.message,e)end;return tostring(l.message)end;local function n(o)a(1,o,"table")local p={}for q,r in pairs(o)do if type(r)=="function"then p[q]=nil elseif type(r)=="table"then if next(r)~=nil then p[q]=n(r)end else p[q]=r end end;return p end;local function s(t,e)a(1,t,"table")if t.type=="table"and t.fields then local u={}for v,w in pairs(t.fields)do if e[v]~=nil then u[v]=s(w,e[v])elseif w.default~=nil then u[v]=w.default end end;return u elseif t.type=="array"then local u={}for f,x in ipairs(e)do u[f]=s(t.fields,x)end;return u elseif t.type=="union"then for g,y in ipairs(t.fields)do local z,A=y:safeParse(e)if z then return A end end;return e else return e end end;local B={}local C={}C.__index=C;function C.new(type,D,E,m,F,G,error)a(1,type,"string","nil")a(2,D,"table","nil")a(3,E,"boolean","nil")a(4,m,"any")a(5,F,"function","nil")a(6,G,"function","nil")a(7,error,"string","nil")local t=setmetatable({},C)t.type=type or"unknown"t.fields=D or{}t.optional=E or false;t.default=m;t.validate=F;t.transform=G or function(e)return s(t,e)end;t.error=error or"Expected value of type '"..type.."', but got '%s' instead."t.min=nil;t.max=nil;t.length=nil;t.email=nil;t.url=nil;t.pattern=nil;t.positive=nil;t.negative=nil;return t end;function C:parse(e)local z,A=self:safeParse(e)if not z then h("Errors:\n"..table.concat(A,"\n"),3)end;return A end;function C:safeParse(e)local H={}if e==nil then if self.optional then return true,self.default else table.insert(H,string.format(self.error,"nil"))return false,H end end;local u;if self.type=="table"and self.fields then u={}for v,t in pairs(self.fields)do if e[v]~=nil then u[v]=e[v]elseif t.default~=nil then u[v]=t.default end end else u=e end;if self.transform then u=self.transform(u)end;if not self.validate and not c(self.type,u)then table.insert(H,string.format(self.error,type(u)))return false,H end;if self.validate then local z,I=self.validate(u)if not z then if c("table",I)then for g,J in ipairs(I)do table.insert(H,J)end else table.insert(H,I or string.format(self.error,type(u)))end end end;if self.type=="table"and self.fields then for v,t in pairs(self.fields)do if u[v]~=nil then local z,K=t:safeParse(u[v])if z then u[v]=K end end end end;if#H>0 then return false,H else return true,u end end;function C:nullable()self.optional=true;local L=self.validate;self.validate=function(e)if e==nil then return true end;return L(e)end;return self end;function C:default(M)self.default=M;self.optional=true;if M~=nil then local N=self.validate(M)if not N then h("Default value is invalid. Expected "..self.type..", but got '"..type(M).."' instead.",3)end end;local L=self.validate;self.validate=function(e)if e==nil then return true end;return L(e)end;return self end;function C:validate(O)a(1,O,"function")self.validate=O;return self end;function C:error(i)a(1,i,"string")self.error=i;return self end;function C:min(M,l)a(1,M,"number")a(2,l,"table","nil")self.validate=self.validate or function(e)return true end;local L=self.validate;self.validate=function(e)local z,I=L(e)if not z then return false,I end;if c("number",e)and e<M then return false,k(l,e,"Value must be at least "..M..", got "..e)elseif c("string",e)and#e<M then return false,k(l,#e,"Length must be at least "..M..", got "..#e)elseif c("array",e)and#e<M then return false,k(l,#e,"Length must be at least "..M..", got "..#e)end;return true end;self.min=M;return self end;function C:max(M,l)a(1,M,"number")a(2,l,"table","nil")self.validate=self.validate or function(e)return true end;local L=self.validate;self.validate=function(e)local z,I=L(e)if not z then return false,I end;local P,Q,R=c("number",e),c("string",e),c("array",e)if not P and not Q and not R then return false,"Expected number, string, or array, got "..type(e)end;if P and e>M then return false,k(l,e,"Value must be at most "..M..", got "..e)elseif Q and#e>M then return false,k(l,#e,"Length must be at most "..M..", got "..#e)elseif R and#e>M then return false,k(l,#e,"Length must be at most "..M..", got "..#e)end;return true end;self.max=M;return self end;function C:positive(l)a(1,l,"table","nil")local L=self.validate or function(e)return true end;self.validate=function(e)local z,I=L(e)if not z then return false,I end;if not c("number",e)then return false,"Expected number, got "..type(e)end;if e<=0 then return false,k(l,e,"Value must be positive, got "..e)end;return true end;self.positive=true;return self end;function C:negative(l)a(1,l,"table","nil")local L=self.validate or function(e)return true end;self.validate=function(e)local z,I=L(e)if not z then return false,I end;if not c("number",e)then return false,"Expected number, got "..type(e)end;if e>=0 then return false,k(l,e,"Value must be negative, got "..e)end;return true end;self.negative=true;return self end;function C:length(S,l)a(1,S,"number")a(2,l,"table","nil")self.validate=self.validate or function(e)return true end;local L=self.validate;self.validate=function(e)local z,I=L(e)if not z then return false,I end;local T;if c("string",e)or c("array",e)then T=#e else return false,"Expected string or array, got "..type(e)end;if T~=S then return false,k(l,T,"Length must be exactly "..S..", got "..T)end;return true end;self.length=S;return self end;function C:email(l)a(1,l,"table","nil")local L=self.validate or function(e)return true end;self.validate=function(e)local z,I=L(e)if not z then return false,I end;if not c("string",e)then return false,"Expected string, got "..type(e)end;local U="^[%w%.%%%+%-]+@[%w%.%-]+%.[a-zA-Z]+$"if not string.match(e,U)then return false,k(l,e,"Value must be a valid email address, got "..e)end;return true end;self.email=true;return self end;function C:url(l)a(1,l,"table","nil")local L=self.validate or function(e)return true end;self.validate=function(e)local z,I=L(e)if not z then return false,I end;if not c("string",e)then return false,k(l,e,"Expected string, got "..type(e))end;local U="[a-z]*://[^ >,;]*"if not string.match(e,U)then return false,k(l,e,"Value must be a valid URL, got "..e)end;return true end;self.url=true;return self end;function C:domain(l)a(1,l,"table","nil")local L=self.validate or function(e)return true end;self.validate=function(e)local z,I=L(e)if not z then return false,I end;if not c("string",e)then return false,"Expected string, got "..type(e)end;if e=="localhost"then return true end;local U="^[%w%.%-]+%.[a-zA-Z]+$"if not string.match(e,U)then return false,k(l,e,"Value must be a valid domain, got "..e)end;return true end;self.domain=true;return self end;function C:ip(l)a(1,l,"table","nil")local L=self.validate or function(e)return true end;self.validate=function(e)local z,I=L(e)if not z then return false,I end;if not c("string",e)then return false,"Expected string, got "..type(e)end;local U="^%d+%.%d+%.%d+%.%d+$"if not string.match(e,U)then return false,k(l,e,"Value must be a valid IP address, got "..e)end;return true end;self.ip=true;return self end;function C:pattern(U,l)a(1,U,"string")a(2,l,"table","nil")local L=self.validate or function(e)return true end;self.validate=function(e)local z,I=L(e)if not z then return false,I end;if not c("string",e)then return false,"Expected string, got "..type(e)end;if not string.match(e,U)then return false,k(l,e,"Value must match pattern '"..U.."', got "..e)end;return true end;self.pattern=U;return self end;function C:enum(V,l)a(1,V,"table")a(2,l,"table","nil")local L=self.validate or function(e)return true end;self.validate=function(e)local z,I=L(e)if not z then return false,I end;for g,M in ipairs(V)do if e==M then return true end end;return false,k(l,e,"Value must be one of "..table.concat(V,", ")..", got "..e)end;self.fields=V;return self end;function C:trim(l)a(1,l,"table","nil")local W=self.transform or function(e)return e end;self.transform=function(e)e=W(e)if type(e)=="string"then return string.match(e,"^%s*(.-)%s*$")end;return e end;return self end;function C:lower(l)a(1,l,"table","nil")local W=self.transform or function(e)return e end;self.transform=function(e)e=W(e)if type(e)=="string"then return string.lower(e)end;return e end;return self end;function C:upper(l)a(1,l,"table","nil")local W=self.transform or function(e)return e end;self.transform=function(e)e=W(e)if type(e)=="string"then return string.upper(e)end;return e end;return self end;function C:between(X,Y,l)a(1,X,"number")a(2,Y,"number")a(3,l,"table","nil")local L=self.validate or function(e)return true end;self.validate=function(e)local z,I=L(e)if not z then return false,I end;local M;if type(e)=="number"then M=e elseif type(e)=="string"then M=#e else return false,"Expected number or string, got "..type(e)end;if M<X or M>Y then return false,k(l,M,"Value must be between "..X.." and "..Y..", got "..M)end;return true end;self.min=X;self.max=Y;return self end;function C:custom(O,l)a(1,O,"function")a(2,l,"table","nil")local L=self.validate or function(e)return true end;self.validate=function(e)local z,I=L(e)if not z then return false,I end;return O(e)end;return self end;function B.string(l)a(1,l,"table","nil")return C.new("string"):validate(function(e)if not c("string",e)then return false,k(l,e,"Expected string, got "..type(e))end;return true end)end;function B.number(l)a(1,l,"table","nil")return C.new("number"):validate(function(e)if not c("number",e)then return false,k(l,e,"Expected number, got "..type(e))end;return true end)end;function B.boolean(l)a(1,l,"table","nil")return C.new("boolean"):validate(function(e)if not c("boolean",e)then return false,k(l,e,"Expected boolean, got "..type(e))end;return true end)end;function B.any(l)a(1,l,"table","nil")return C.new("any"):validate(function(e)return true end)end;function B.table(D,l)a(1,D,"table")a(2,l,"table","nil")return C.new("table",D):validate(function(e)local H={}if not c("table",e)then table.insert(H,"Expected table, got "..type(e))return false,H end;for v,t in pairs(D)do local z,I=t:safeParse(e[v])if not z then if type(I)=="table"then for g,J in ipairs(I)do table.insert(H,"Field '"..v.."': "..J)end else table.insert(H,"Field '"..v.."': "..I)end end end;if#H>0 then return false,H else return true end end)end;function B.array(Z,l)a(1,Z,"table")a(2,l,"table","nil")return C.new("array",Z):validate(function(e)local H={}if not c("table",e)then table.insert(H,"Expected array, got "..type(e))return false,H end;for f,x in ipairs(e)do local z,I=Z:safeParse(x)if not z then if type(I)=="table"then for g,J in ipairs(I)do table.insert(H,"Element "..f..": "..J)end else table.insert(H,"Element "..f..": "..I)end end end;if#H>0 then return false,H else return true end end)end;function B.custom(_)a(1,_,"function")return C.new("custom"):validate(_)end;function B.union(a0,l)a(1,a0,"table")a(2,l,"table","nil")return C.new("union",a0):validate(function(e)local H={}for f,t in ipairs(a0)do local z,A=t:safeParse(e)if z then return true,A else table.insert(H,"Option "..f..": "..table.concat(A,", "))end end;return false,k(l,e,table.concat(H,"\n"))end)end;function B.peripheral(a1,l)a(1,a1,"string","nil")a(2,l,"table","nil")return C.new("peripheral"):validate(function(e)if not a1 then local a2=peripheral.getName(e)if not a2 then return false,k(l,e,"Expected peripheral, got nil")end;return true end;if peripheral.getType(e)~=a1 then return false,k(l,e,"Expected peripheral of type "..a1 ..", got "..peripheral.getType(e))end;return true end)end;function B.toTable(t)a(1,t,"table")t=n(t)local function a3(a4)if getmetatable(a4)==C then local a5={type=a4.type}if a4.optional then a5.optional=true end;if a4.default~=nil then a5.default=a4.default end;if a4.error then a5.error=a4.error end;if a4.type=="table"and a4.fields then a5.fields={}for v,w in pairs(a4.fields)do a5.fields[v]=a3(w)end elseif a4.type=="array"then a5.element=a3(a4.fields)elseif a4.type=="enum"then a5.values=a4.fields elseif a4.type=="union"then a5.options={}for f,a6 in ipairs(a4.fields)do a5.options[f]=a3(a6)end end;return a5 else return a4 end end;return a3(t)end;function B.toJSON(t)return textutils.serializeJSON(B.toTable(t))end;function B.toFile(t,a2,type)a(1,t,"table")a(2,a2,"string")a(3,type,"string")if type~="json"and type~="lua"then h("Invalid file type: "..type)end;if not a2 then h("File name is required")end;local a7=fs.combine(shell.dir(),a2 .."."..type)local a8=io.open(a7,"w")if not a8 then h("Could not open file for writing: "..a7)end;if type=="json"then a8:write(B.toJSON(t))elseif type=="lua"then a8:write("return "..textutils.serialize(B.toTable(t)))else h("Unsupported file type: "..type)end;a8:close()end;return B
